<!DOCTYPE HTML>
<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION

 The CodeProject article submission template (HTML version)

Using this template will help us post your article sooner. To use, just
follow the 3 easy steps below:

     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets.

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
    <title>CodeProject</title>
    <Style>
        BODY, P, TD {
            font-family: Verdana, Arial, Helvetica, sans-serif;
            font-size: 10pt;
        }

        H2, H3, H4, H5 {
            color: #ff9900;
            font-weight: bold;
        }

        H2 {
            font-size: 13pt;
        }

        H3 {
            font-size: 12pt;
        }

        H4 {
            font-size: 10pt;
            color: black;
        }

        PRE {
            BACKGROUND-COLOR: #FBEDBB;
            FONT-FAMILY: "Courier New", Courier, mono;
            WHITE-SPACE: pre;
        }

        CODE {
            COLOR: #990000;
            FONT-FAMILY: "Courier New", Courier, mono;
        }
    </Style>
    <link type="text/css" rel="stylesheet"
          href="https://codeproject.global.ssl.fastly.net/App_Themes/CodeProject/Css/Main.min.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
    <!--------------------------------------------------------------------------->
    <!-------------------------------     STEP 1      --------------------------->
    <!--  Fill in the details (CodeProject will reformat this section for you) -->

<pre>
Title:       Chess engine
Author:      Kristian Ekman
Email:       kristian.ekman.swe@gmail.com
Language:    C# 6.0
Platform:    Windows
Technology:  Windows Forms
Level:       Advanced
Description: Chess engine and simple chess user interface.
Section      General Programming
SubSection   Artificial Intelligence and Machine Learning
License:     <a href="https://opensource.org/licenses/MS-RL">Microsoft Reciprocal License</a>
</pre>

    <!-------------------------------     STEP 2      --------------------------->
    <!--  Include download and sample image information.                       -->

    <ul class=download>
        <li><a href="Source.zip">Download source - 121 Kb</a></li>
    </ul>

    <p>
        <img src="chessui.png" alt="Sample Image - maximum width is 600 pixels"
             style="width:400px; height:200px">
    </p>

    <!-------------------------------     STEP 3      --------------------------->
    <!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->

    <h2>Introduction</h2>

    <p>
        This is a fully functional yet simple chess program that aims to help developers to understand how a chess engine could be implemented.<br />
        It is a standard object oriented solution and I think advanced and intermediate C#-developers should have no problem to follow the code logic.<br />
        The focus has not been to make a fast and high rated chess engine. I have developed a working chess AI that plays descent good moves with code that is easy to read and understand.<br />
        The goal has been to correctly implement Alpha Beta Pruning and Zobrist Hashing.
    </p>
    <p>Anyone interested in chess programming could perhaps learn something by studying the source code.</p>

    <h2>Background</h2>
    <p>
        I have tried before (about ten years ago) to implement a chess engine. This time I decided to use the TDD test first approach.<br />
        I like TDD and I think using TDD was the main reason the engine worked this time. It is very important that the rules of chess are 100% correct implemented.<br />
        Equally important is that undoing moves result exactly in to the previous state.<br />
        I also think that TDD contributes to good code structure and a maintainable system design. It took me about six weeks to finish the first version.
    </p>


    <h2>The code</h2>
    <p>
        The solution consists of two main projects. The engine (chess.dll) and the user interface.<br />
        Chess.dll has everything about the game, the board, the rules and the engine.<br />
        It also contains all tests. I saw no reason for having unit-tests in a separate project in this implementation. This way one can easily see what unit-tests belongs to which class.<br />
        There are currently 77 tests. Most of them are very fast and code coverage is about 100%.
        Total number of lines of code are just under 3000, including tests and user interface.<br />
        The engine and game class where most of the logic is, is under 700 lines of code.
    </p>
    <p>The Chess UI is a simple Windows forms application with only a few features like load, save and setting the time for computer to think.</p>

    <p>
        There is a lot of free and good literature on the web about explaining the different algorithms and techniques in a chess engine.<br />
        The goal of this article is not to explain them again. Instead it provides links to the sites that helped me.<br />
    </p>

    <h2>Features</h2>
    <ul>
        <li>Iterative <a href="http://will.thimbleby.net/algorithms/doku.php?id=minimax_search_with_alpha-beta_pruning">Alpha-Beta Pruning</a>, which drastically decreases the number of positions that needs to be analyzed.<br /> At depth zero a depth two <a href="https://chessprogramming.wikispaces.com/Quiescence+Search">Quiescence Search</a> is also performed to prevent the risk of horizon effect.</li>
        <li><a href="https://chessprogramming.wikispaces.com/Zobrist+Hashing">Zobrist Hashing</a>. A very cool and powerful algorithm invented by some very smart guy long time ago. A few million positions are cashed in a dictionary so every position only has to be calculated once.</li>
        <li>Parallel threads to increase performance of engine if multiple cores are available.</li>
        <li>The chess board is represented by a single square[64] array. (Bit-boards are a lot faster but perhaps little bit more complicated.)</li>
        <li>Score of the position is based on material and a positional score for each piece. In the opening, a few basic opening principles gives extra points. Special calculations are also performed in the end game.</li>
        <li>Draw by repetition, insufficient material and stale mate are also evaluated.</li>
        <li><i>Opening book is not yet implemented</i></li>
    </ul>



    <h2>Performance</h2>
    <p>
        The engine analyses about 50k positions/sec on my dual core 2.7Ghz laptop. Which is mostly enough to see about five or six moves ahead in the middle game.<br />
        Most average skilled chess players (like me) should have quite some difficulty beating the engine given the same time to think.<br />
        When testing it in a chess.com CPU game, I estimate it has a rating around 1300.<br />
        I think the best way to improve its performance would be to replace board representation with a bit board.<br />
        That would increase move generation and position evaluation so even deeper searches could be performed.
    </p>

    <p>
        The Zobrist Key is stored in a in memory database together with an integer containing a few data about the position.<br />
        These data only has to be calculated once. Next time same position hash shows up, the database is queried with that hash key.
    </p>
    <p>
        This is the data that is packed in an 32 bit integer.<br />
        The data is packed to decrease size and increase access to the database with the following function using bit shifts.
    </p>
    <ol>
        <li>Command Number (7 bits), used for cleaning old positions not needed.</li>
        <li>If the move was legal i.e. own king in check. (1 bit)</li>
        <li>If own king is in check (1 bit)</li>
        <li>The score of the board. (13 bits)</li>
        <li>How many recursions it took to find the score. A deeper search replaces less deeper. (5 bits)</li>
        <li>DrawByRepetion, UnsufficienMaterial, StaleMate and Mate. (One bit each)</li>
    </ol>
<pre>
    <code>
    int Pack(byte commandNo, bool legal, bool check, int score, int recursions, ScoreInfo scorInfo) {
            var build = (int)commandNo;
            build <<= 1;
            build |= (legal ? 1 : 0);
            build <<= 1;
            build |= (check ? 1 : 0);
            build <<= 1;
            build |= score < 0 ? 1 : 0;
            build <<= 13;
            build |= Math.Abs(score);
            build <<= 5;
            build |= recursions;
            build <<= 4;
            build |= (byte)scorInfo;
            return build;
        }
    </code>
</pre>

    <p>Unpacked in the following way</p>
<pre>
    <code>
void Unpack(int build, out byte oCommandNo, out bool oLegal, out bool check, out ScoreInfo oScoreInfo, out int oScore, out byte oRecursions) {
        oCommandNo = (byte)((build >> 25) & 0x7F);
        oLegal = ((build >> 24) & 1) == 1;
        check = ((build >> 23) & 1) == 1;
        var negScore = ((build >> 22) & 1) == 1;
        oScore = (build >> 9) & 0x1FFF;
        oScore = negScore ? oScore * -1 : oScore;
        oRecursions = (byte)((build >> 4) & 0x1F);
        oScoreInfo = (ScoreInfo)(build & 0xF);
    }
    </code>
</pre>

    <!--
        <pre>//
        // Any source code blocks look like this
        //
        var i = 0;
        ...</pre>

        <p>Remember to set the Language of your code snippet using the Language dropdown. </p>

        <p>Use the &quot;var&quot; button to wrap Variable or class names in &amp;lt;code&amp;gt;
        tags like <code>this</code>. </p>
        -->

    <h2>Points of Interest</h2>
    <p>
        The alpha beta algorithm is probably the most challenging part of a chess engine. There are many pseudo code examples on the Internet, but the only one that I managed to get to work is the one from <a href="http://will.thimbleby.net/algorithms/doku.php?id=minimax_search_with_alpha-beta_pruning">Algorithm Wiki</a><br />
    </p>

    <p>
        Hashing is an important part of Chess programming. The board has to save a position score for faster access. The hash is stored in an 64 bit datatype but there are many more possible states that a chess game can be in.<br />
        I find it quite remarkable that there were no hash collisions after I implemented the Zobrist hashing that very effectively spreads the risk of having hash collisions.<br />
    </p>
    <p>It is important to run performance profiling. The faster the analysis becomes more positions are analyzed every second and even some small improvements can have large effects on over all performance.</p>
    <p>An other good site for learning is the <a href="https://chessprogramming.wikispaces.com/">Chess Programming Wiki</a></p>
    <p>
        The source is hosted on Git hub <a href="https://github.com/KristianEkman/ChessAi">at this location.</a> There might be some changes later on but for now i think it is time to give this little hobby project a rest!
    </p>

    <h2>History</h2>
    <p>Jan 31 2017 - Version 1.0 </p>
    <br />
    <br />
    <br />
    <p>Finally, thanks to my wife who put up with me during these few weeks in the winter of 2017.</p>
    <p>Happy code reading and good luck on your chess programming learning!</p>
    <!-------------------------------    That's it!   --------------------------->
</body>
</html>
